# TS_DesignPattern

# 생선 디자인 패턴(Creational Design Pattern)

## 객체의 인스턴스가 생성되는 동안 적용되는 디자인 패턴

- 팩토리 메서드(Factory Method): 생성자 대신에 팩토리의 **추상 메서드를 사용하여 인스턴스를 생성**토록 함으로써 서브클래스는 이러한 메서드를 구현하거나 재정의하여 생성 내용을 변경할 수 있다.
- 추상 팩토리(Abstract Factory): 호환 가능한 팩토리와 해당 제품의 인터페이스를 정의한다. 따라서 전달하는 팩토리를 변경하면 생성 제품의 군(family)를 변경할 수 있다. / 전체 팩토리 교체를 통해 동일한 생산방식을 따르면서 서로 다른 제품을 생산할 수 있게 한다.
- 빌더(Builder): 복잡한 객체를 생성하는 단계를 정의한다. 그리고 단계의 순서를 변경하거나 다른 빌더 구현을 사용하여 생성 내용을 변경한다.
- 프로토타입(Prototype): 파라미터화 된 프로토타입을 복제하여 객체를 생성한다. 따라서 프로토타입을 교체하면 다양한 제품을 생성할 수 있다.
- 싱글톤(Singleton): 하나의 인스턴스만 생성되게 한다.(특정 범위 내에서)

# 구조 디자인 패턴(Structural Patterns)

## 객체 구성에 관한 패턴

## 구조 패턴을 자세히 살펴보면 두 가지로 나눌 수 있다.

- 구조 클래스 패턴(Structural class Patterns)은 이해 관계자들과 작업하는 패턴
- 구조 객체 패턴(Structural object patterns)은 컴포지트 패턴처럼 조각들을 함께 묶는 패턴

- 컴포지트(Composite): 원시(primitive)객체와 컴포지트 객체를 사용해 트리 구조를 만든다. ex. DOM 트리
- 데코레이터(Decorator): 클래스나 객체에 기능을 동적으로 추가한다.
- 어댑터(Adapter): 일반적인 인터페이스를 제공하고 다른 구체적인 어댑터를 구현하여 다른 어댑터와 작업한다. 단일 콘텐츠 관리 시스템에서 다양한 데이터 베이스 선택 기능을 제공하는 경우가 좋은 예다. / 기존 클래스나 객체를 다른 기존 클라이언트와 연결한다. 따라서 어댑터 패턴을 이용하면 본래 함께 작업할 계획이 없었던 클래스도 서로 협력하게 만들 수 있다.
- 브릿지(Bridge): 구현에서 추상화를 분리하고 이 둘이 각자 독립적으로 변형할 수 있게 한다.
- 퍼사드(Facade): 복잡한 서브시스템 조합을 위해 단순화된 인터페이스를 제공한다.
- 플라이웨이트(Flyweight): 자주 사용되는 무상태(stateless)객체를 공유하여 메모리 효율과 성능을 향상시킨다.
- 프록시(Proxy): 관리하는 객체에 액세스할 때 추가적인 책임을 담당하는 대리인 역할을 수행한다.
